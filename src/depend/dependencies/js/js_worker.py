"""Functions to handle JavaScript files"""
import json
import logging
from datetime import datetime

import jmespath
import yaml
from pyarn import lockfile

from depend.constants import REGISTRY
from depend.dependencies.dep_types import Result


def handle_yarn_lock(req_file_data: str) -> Result:
    """
    Parse yarn lock file
    :param req_file_data: Content of yarn.lock
    :return: list of requirement and specs
    """
    res: Result = {
        "import_name": "",
        "lang_ver": [],
        "pkg_name": "",
        "pkg_ver": "",
        "pkg_lic": ["Other"],
        "pkg_err": {},
        "pkg_dep": [],
        "timestamp": datetime.utcnow().isoformat(),
    }
    if "lockfile v1" in req_file_data:
        parsed_lockfile = lockfile.Lockfile.from_str(req_file_data)
        unfiltered_content: dict = json.loads(parsed_lockfile.to_json())
    else:
        unfiltered_content = yaml.safe_load(req_file_data)
    for package in unfiltered_content.keys():
        if package.startswith("_"):
            continue
        res["pkg_dep"].append(
            str(package.split(",")[0].rsplit("@", 1)[0])
            + ";"
            + str(unfiltered_content[package].get("version", ""))
        )
    return res


def handle_json(req_file_data: str) -> Result:
    """
    Parse json files generated by npm or yarn
    :param req_file_data: Content of package.json
    :return: list of requirement and specs
    """
    package_data = json.loads(req_file_data)
    res: Result = {
        "import_name": "",
        "lang_ver": [],
        "pkg_name": "",
        "pkg_ver": "",
        "pkg_lic": ["Other"],
        "pkg_err": {},
        "pkg_dep": [],
        "timestamp": datetime.utcnow().isoformat(),
    }
    handle_js(package_data, res)
    return res


def nested_deps(json_input):
    for item, value in json_input.items():
        yield f"{item};{value.get('version', '')}"
        if "dependencies" in value:
            yield from nested_deps(value.get("dependencies"))


def handle_js(package_data, result):
    queries = REGISTRY["javascript"]
    version_q: jmespath.parser.ParsedResult = queries["version"]
    license_q: jmespath.parser.ParsedResult = queries["license"]
    dependencies_q: jmespath.parser.ParsedResult = queries["dependency"]
    repo_q: jmespath.parser.ParsedResult = queries["repo"]
    version = version_q.search(package_data)
    if version:
        result["pkg_ver"] = version
    else:
        logging.error("Version query failed")
    engines = package_data.get("engines", {})
    if isinstance(engines, dict):
        result["lang_ver"] = [engines.get("node", "")]
    else:
        # The documentation specifies that this entry must be a dictionary
        # This was added because of a failing case in tests
        result["lang_ver"] = []
    pkg_lic = ["Other"]
    lic_info = license_q.search(package_data)
    if isinstance(lic_info, str):
        pkg_lic = lic_info.split(",")
    #     The cases below are just to as to add support for older packages
    elif isinstance(lic_info, dict):
        pkg_lic = [lic_info.get("type", "Other")]
    elif lic_info and isinstance(lic_info, list):
        if isinstance(lic_info[0], dict):
            pkg_lic = list({single_lic.get("type", "Other") for single_lic in lic_info})
        elif isinstance(lic_info[0], str):
            pkg_lic = lic_info
    result["pkg_lic"] = pkg_lic
    dep_data = dependencies_q.search(package_data)
    result["pkg_dep"] = []
    if dep_data:
        if any(isinstance(i, dict) for i in dep_data.values()):
            result["pkg_dep"] = [*nested_deps(dep_data)]
        else:
            for item, value in dep_data.items():
                result["pkg_dep"].append(f"{item};{value}")
    repo = repo_q.search(package_data) or ""
    return repo
